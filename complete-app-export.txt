================================================================================
ðŸŒ± THE PLANT STORE - COMPLETE CODE EXPORT FOR DEPLOYMENT
================================================================================
Generated: 06/27/2025 09:22:29

================================================================================
ðŸ“¦ PACKAGE.JSON
================================================================================
{
  "name": "app",
  "private": true,
  "engines": {
    "node": "18.x"
  },

  "scripts": {
    "dev": "next dev",
    "db:deploy": "prisma db push",
    "build": "prisma generate && next build",
    "postinstall": "prisma generate",
    "start": "next start",
    "lint": "eslint ."
  },
  "prisma": {
    "seed": "tsx --require dotenv/config scripts/seed.ts"
  },
  "devDependencies": {
    "@next/swc-wasm-nodejs": "13.5.1",
    "@types/node": "20.6.2",
    "@types/react": "18.2.22",
    "@types/react-dom": "18.2.7",
    "@typescript-eslint/eslint-plugin": "^8.35.0",
    "@typescript-eslint/parser": "^8.35.0",
    "eslint": "^9.29.0",
    "eslint-config-next": "15.3.0",
    "eslint-plugin-prettier": "5.1.3",
    "eslint-plugin-react-hooks": "^5.2.0",
    "postcss": "8.4.30",
    "prisma": "^6.10.1",
    "tailwind-merge": "2.5.2",
    "tailwindcss": "3.3.3",
    "tailwindcss-animate": "1.0.7",
    "ts-node": "10.9.2",
    "tsx": "4.20.3",
    "typescript": "5.2.2"
  },
  "dependencies": {
    "@floating-ui/react": "0.26.0",
    "@headlessui/react": "1.7.18",
    "@hookform/resolvers": "3.9.0",
    "@next-auth/prisma-adapter": "1.0.7",
    "@prisma/client": "^6.10.1",
    "@radix-ui/react-accordion": "1.2.0",
    "@radix-ui/react-alert-dialog": "1.1.1",
    "@radix-ui/react-aspect-ratio": "1.1.0",
    "@radix-ui/react-avatar": "1.1.0",
    "@radix-ui/react-checkbox": "1.1.1",
    "@radix-ui/react-collapsible": "1.1.0",
    "@radix-ui/react-context-menu": "2.2.1",
    "@radix-ui/react-dialog": "1.1.1",
    "@radix-ui/react-dropdown-menu": "2.1.1",
    "@radix-ui/react-hover-card": "1.1.1",
    "@radix-ui/react-label": "2.1.0",
    "@radix-ui/react-menubar": "1.1.1",
    "@radix-ui/react-navigation-menu": "1.2.0",
    "@radix-ui/react-popover": "1.1.1",
    "@radix-ui/react-progress": "1.1.0",
    "@radix-ui/react-radio-group": "1.2.0",
    "@radix-ui/react-scroll-area": "1.1.0",
    "@radix-ui/react-select": "2.1.1",
    "@radix-ui/react-separator": "1.1.0",
    "@radix-ui/react-slider": "1.2.0",
    "@radix-ui/react-slot": "1.1.0",
    "@radix-ui/react-switch": "1.1.0",
    "@radix-ui/react-tabs": "1.1.0",
    "@radix-ui/react-toast": "1.2.1",
    "@radix-ui/react-toggle": "1.1.0",
    "@radix-ui/react-toggle-group": "1.1.0",
    "@radix-ui/react-tooltip": "1.1.2",
    "@tanstack/react-query": "5.0.0",
    "@types/bcryptjs": "2.4.6",
    "@types/jsonwebtoken": "9.0.5",
    "@types/plotly.js": "2.35.5",
    "@types/react-plotly.js": "2.6.3",
    "autoprefixer": "10.4.15",
    "bcrypt": "5.1.1",
    "bcryptjs": "2.4.3",
    "chart.js": "4.4.9",
    "class-variance-authority": "0.7.0",
    "clsx": "2.1.1",
    "cmdk": "1.0.0",
    "cookie": "1.0.2",
    "csv": "6.3.11",
    "date-fns": "3.6.0",
    "dayjs": "1.11.13",
    "dotenv": "16.5.0",
    "embla-carousel-react": "8.3.0",
    "formik": "2.4.5",
    "framer-motion": "10.18.0",
    "gray-matter": "4.0.3",
    "input-otp": "1.2.4",
    "jotai": "2.6.0",
    "jsonwebtoken": "9.0.2",
    "lodash": "4.17.21",
    "lucide-react": "0.446.0",
    "mapbox-gl": "1.13.3",
    "next": "14.2.28",
    "next-auth": "4.24.11",
    "next-themes": "0.3.0",
    "plotly.js": "2.35.3",
    "react": "18.2.0",
    "react-chartjs-2": "5.3.0",
    "react-datepicker": "6.1.0",
    "react-day-picker": "8.10.1",
    "react-dom": "18.2.0",
    "react-hook-form": "7.53.0",
    "react-hot-toast": "2.4.1",
    "react-intersection-observer": "9.8.0",
    "react-is": "18.3.1",
    "react-plotly.js": "2.6.0",
    "react-resizable-panels": "2.1.3",
    "react-select": "5.8.0",
    "react-use": "17.6.0",
    "recharts": "2.15.3",
    "sonner": "1.5.0",
    "swr": "2.2.4",
    "tailwind-scrollbar-hide": "1.1.7",
    "vaul": "0.9.9",
    "webpack": "5.99.5",
    "yup": "1.3.0",
    "zod": "3.23.8",
    "zustand": "5.0.3"
  }
}


================================================================================
âš™ï¸ NEXT.CONFIG.JS
================================================================================
const path = require('path');

/** @type {import('next').NextConfig} */
const nextConfig = {
  distDir: process.env.NEXT_DIST_DIR || '.next',
  output: process.env.NEXT_OUTPUT_MODE,
  experimental: {
    outputFileTracingRoot: path.join(__dirname, '../'),
  },
  eslint: {
    ignoreDuringBuilds: true,
  },
  typescript: {
    ignoreBuildErrors: false,
  },
  images: { unoptimized: true },
};

module.exports = nextConfig;


================================================================================
ðŸ—„ï¸ PRISMA SCHEMA
================================================================================
// The House Plant Store Database Schema
generator client {
    provider = "prisma-client-js"
    binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

// NextAuth.js required models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// User Management
enum UserRole {
  CUSTOMER
  SUPER_ADMIN
  PLANT_MANAGER
  ORDER_MANAGER
  VIEWER
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?
  password      String?
  role          UserRole  @default(CUSTOMER)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  accounts     Account[]
  sessions     Session[]
  orders       Order[]
  reviews      Review[]
  cartItems    CartItem[]
  addresses    Address[]
}

// Address Management for SA Provinces
enum Province {
  GAUTENG
  WESTERN_CAPE
  KWAZULU_NATAL
  EASTERN_CAPE
  LIMPOPO
  MPUMALANGA
  NORTH_WEST
  NORTHERN_CAPE
  FREE_STATE
}

model Address {
  id           String    @id @default(cuid())
  userId       String
  firstName    String
  lastName     String
  company      String?
  vatNumber    String?
  addressLine1 String
  addressLine2 String?
  city         String
  province     Province
  postalCode   String
  phone        String
  isDefault    Boolean   @default(false)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  // Relations
  user   User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  orders Order[]
}

// Product Management
enum CareLevel {
  EASY
  MODERATE
  ADVANCED
}

enum LightRequirement {
  LOW
  MEDIUM
  BRIGHT
  DIRECT_SUN
}

enum WateringFrequency {
  WEEKLY
  BI_WEEKLY
  MONTHLY
}

enum PlantSize {
  SMALL
  MEDIUM
  LARGE
}

enum GrowthRate {
  SLOW
  MODERATE
  FAST
}

model Category {
  id          String    @id @default(cuid())
  name        String    @unique
  slug        String    @unique
  description String?
  image       String?
  parentId    String?
  isActive    Boolean   @default(true)
  sortOrder   Int       @default(0)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  parent   Category? @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children Category[] @relation("CategoryHierarchy")
  products Product[]
}

model Product {
  id                String             @id @default(cuid())
  name              String
  slug              String             @unique
  description       String?
  shortDescription  String?
  price             Decimal            @db.Decimal(10, 2)
  compareAtPrice    Decimal?           @db.Decimal(10, 2)
  sku               String?            @unique
  stockQuantity     Int                @default(0)
  lowStockThreshold Int                @default(10)
  weight            Decimal?           @db.Decimal(8, 2)
  dimensions        String?
  isActive          Boolean            @default(true)
  isFeatured        Boolean            @default(false)
  sortOrder         Int                @default(0)
  
  // Plant-specific fields
  careLevel         CareLevel?
  lightRequirement  LightRequirement?
  wateringFrequency WateringFrequency?
  isPetSafe         Boolean?
  plantSize         PlantSize?
  growthRate        GrowthRate?
  careInstructions  String?
  
  // SEO
  metaTitle         String?
  metaDescription   String?
  
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt

  // Relations
  categoryId   String
  category     Category       @relation(fields: [categoryId], references: [id])
  images       ProductImage[]
  reviews      Review[]
  orderItems   OrderItem[]
  cartItems    CartItem[]
}

model ProductImage {
  id        String  @id @default(cuid())
  productId String
  url       String
  altText   String?
  sortOrder Int     @default(0)
  isPrimary Boolean @default(false)

  // Relations
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)
}

// Shopping Cart
model CartItem {
  id        String   @id @default(cuid())
  userId    String
  productId String
  quantity  Int      @default(1)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([userId, productId])
}

// Order Management
enum OrderStatus {
  PENDING
  CONFIRMED
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
  REFUNDED
}

enum PaymentMethod {
  YOCO
  EFT
  PAYJUSTNOW
}

enum PaymentStatus {
  PENDING
  PAID
  FAILED
  REFUNDED
}

enum ShippingMethod {
  STANDARD
  COLLECTION_JHB
}

model Order {
  id              String         @id @default(cuid())
  orderNumber     String         @unique
  userId          String
  status          OrderStatus    @default(PENDING)
  paymentMethod   PaymentMethod?
  paymentStatus   PaymentStatus  @default(PENDING)
  shippingMethod  ShippingMethod @default(STANDARD)
  
  // Totals
  subtotal        Decimal        @db.Decimal(10, 2)
  shippingCost    Decimal        @default(0) @db.Decimal(10, 2)
  taxAmount       Decimal        @default(0) @db.Decimal(10, 2)
  discountAmount  Decimal        @default(0) @db.Decimal(10, 2)
  totalAmount     Decimal        @db.Decimal(10, 2)
  
  // Shipping Information
  shippingAddressId String?
  trackingNumber    String?
  shippedAt         DateTime?
  deliveredAt       DateTime?
  
  // Payment Information
  paymentReference  String?
  paidAt            DateTime?
  
  // Notes
  customerNotes     String?
  adminNotes        String?
  
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt

  // Relations
  user            User       @relation(fields: [userId], references: [id])
  shippingAddress Address?   @relation(fields: [shippingAddressId], references: [id])
  items           OrderItem[]
}

model OrderItem {
  id          String  @id @default(cuid())
  orderId     String
  productId   String
  quantity    Int
  price       Decimal @db.Decimal(10, 2)
  totalPrice  Decimal @db.Decimal(10, 2)
  
  // Snapshot of product details at time of order
  productName String
  productSku  String?

  // Relations
  order   Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id])
}

// Reviews System
model Review {
  id        String   @id @default(cuid())
  userId    String
  productId String
  rating    Int      // 1-5 stars
  title     String?
  comment   String?
  isVerified Boolean @default(false)
  isApproved Boolean @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([userId, productId])
}

// Shipping Rates by Province
model ShippingRate {
  id        String   @id @default(cuid())
  province  Province @unique
  rate      Decimal  @db.Decimal(8, 2)
  freeThreshold Decimal? @db.Decimal(10, 2) // Free shipping threshold
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Contact Forms
model ContactForm {
  id        String   @id @default(cuid())
  name      String
  email     String
  subject   String
  message   String
  status    String   @default("NEW") // NEW, REPLIED, CLOSED
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

================================================================================
ðŸ”— DATABASE CONNECTION (lib/db.ts)
================================================================================
import { PrismaClient } from '@prisma/client'

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined
}

export const prisma = globalForPrisma.prisma ?? new PrismaClient()

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma


================================================================================
ðŸ“± APP LAYOUT (app/layout.tsx)
================================================================================

import type { Metadata } from 'next'
import { Inter } from 'next/font/google'
import './globals.css'
import { ThemeProvider } from '@/components/theme-provider'
import { Toaster } from '@/components/ui/toaster'
import { AuthProvider } from '@/components/auth-provider'

const inter = Inter({ subsets: ['latin'] })

export const metadata: Metadata = {
  title: 'The House Plant Store - South Africa\'s Premier Plant Shop',
  description: 'Discover beautiful indoor plants, outdoor plants, succulents and accessories. Premium plant delivery across all South African provinces.',
  keywords: 'plants, indoor plants, outdoor plants, succulents, plant delivery, South Africa, houseplants',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body className={inter.className} suppressHydrationWarning>
        <ThemeProvider attribute="class" defaultTheme="light" enableSystem>
          <AuthProvider>
            {children}
            <Toaster />
          </AuthProvider>
        </ThemeProvider>
      </body>
    </html>
  )
}


================================================================================
ðŸ  HOME PAGE (app/page.tsx)
================================================================================

import { Header } from '@/components/layout/header'
import { Footer } from '@/components/layout/footer'
import { HeroSection } from '@/components/home/hero-section'
import { FeaturedCategories } from '@/components/home/featured-categories'
import { FeaturedProducts } from '@/components/home/featured-products'
import { PlantCareSection } from '@/components/home/plant-care-section'
import { NewsletterSection } from '@/components/home/newsletter-section'

export default function HomePage() {
  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <main className="flex-1">
        <HeroSection />
        <FeaturedCategories />
        <FeaturedProducts />
        <PlantCareSection />
        <NewsletterSection />
      </main>
      <Footer />
    </div>
  )
}


================================================================================
ðŸŒ ENVIRONMENT VARIABLES (.env)
================================================================================
# Showing structure only (sensitive data hidden) NODE_ENV =***HIDDEN*** NEXTAUTH_SECRET =***HIDDEN*** NEXTAUTH_URL =***HIDDEN*** DATABASE_URL =***HIDDEN***

================================================================================
âš¡ TYPESCRIPT CONFIG (tsconfig.json)
================================================================================
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".build/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}


================================================================================
ðŸŽ¨ TAILWIND CONFIG (tailwind.config.ts)
================================================================================
import type { Config } from 'tailwindcss';

const config: Config = {
  darkMode: ['class'],
  content: [
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
    './app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      backgroundImage: {
        'gradient-radial': 'radial-gradient(var(--tw-gradient-stops))',
        'gradient-conic':
          'conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))',
      },
      borderRadius: {
        lg: 'var(--radius)',
        md: 'calc(var(--radius) - 2px)',
        sm: 'calc(var(--radius) - 4px)',
      },
      colors: {
        background: 'hsl(var(--background))',
        foreground: 'hsl(var(--foreground))',
        card: {
          DEFAULT: 'hsl(var(--card))',
          foreground: 'hsl(var(--card-foreground))',
        },
        popover: {
          DEFAULT: 'hsl(var(--popover))',
          foreground: 'hsl(var(--popover-foreground))',
        },
        primary: {
          DEFAULT: 'hsl(var(--primary))',
          foreground: 'hsl(var(--primary-foreground))',
        },
        secondary: {
          DEFAULT: 'hsl(var(--secondary))',
          foreground: 'hsl(var(--secondary-foreground))',
        },
        muted: {
          DEFAULT: 'hsl(var(--muted))',
          foreground: 'hsl(var(--muted-foreground))',
        },
        accent: {
          DEFAULT: 'hsl(var(--accent))',
          foreground: 'hsl(var(--accent-foreground))',
        },
        destructive: {
          DEFAULT: 'hsl(var(--destructive))',
          foreground: 'hsl(var(--destructive-foreground))',
        },
        border: 'hsl(var(--border))',
        input: 'hsl(var(--input))',
        ring: 'hsl(var(--ring))',
        chart: {
          '1': 'hsl(var(--chart-1))',
          '2': 'hsl(var(--chart-2))',
          '3': 'hsl(var(--chart-3))',
          '4': 'hsl(var(--chart-4))',
          '5': 'hsl(var(--chart-5))',
        },
      },
      keyframes: {
        'accordion-down': {
          from: {
            height: '0',
          },
          to: {
            height: 'var(--radix-accordion-content-height)',
          },
        },
        'accordion-up': {
          from: {
            height: 'var(--radix-accordion-content-height)',
          },
          to: {
            height: '0',
          },
        },
      },
      animation: {
        'accordion-down': 'accordion-down 0.2s ease-out',
        'accordion-up': 'accordion-up 0.2s ease-out',
      },
    },
  },
  plugins: [require('tailwindcss-animate')],
};
export default config;


================================================================================
ðŸ”Œ API ROUTES
================================================================================

--- API ROUTE: /app/api/admin/products/route.ts ---

export const dynamic = 'force-dynamic'

import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { prisma } from '@/lib/db'
import { Decimal } from '@prisma/client/runtime/library'

// Import NextAuth configuration to get session
async function getAuthOptions() {
  const { default: NextAuth } = await import('next-auth')
  const CredentialsProvider = (await import('next-auth/providers/credentials')).default
  const { PrismaAdapter } = await import('@next-auth/prisma-adapter')
  const bcrypt = await import('bcryptjs')

  return {
    adapter: PrismaAdapter(prisma),
    providers: [
      CredentialsProvider({
        name: 'credentials',
        credentials: {
          email: { label: 'Email', type: 'email' },
          password: { label: 'Password', type: 'password' }
        },
        async authorize(credentials) {
          if (!credentials?.email || !credentials?.password) {
            return null
          }

          const user = await prisma.user.findUnique({
            where: { email: credentials.email }
          })

          if (!user || !user.password) {
            return null
          }

          const isPasswordValid = await bcrypt.compare(
            credentials.password,
            user.password
          )

          if (!isPasswordValid) {
            return null
          }

          return {
            id: user.id,
            email: user.email,
            name: user.name,
            role: user.role,
          }
        }
      })
    ],
    session: {
      strategy: 'jwt' as const
    },
    callbacks: {
      async jwt({ token, user }: any) {
        if (user) {
          token.role = user.role
        }
        return token
      },
      async session({ session, token }: any) {
        if (session?.user) {
          session.user.id = token.sub
          session.user.role = token.role
        }
        return session
      }
    },
    pages: {
      signIn: '/auth/signin',
    }
  }
}

export async function POST(request: NextRequest) {
  try {
    // Get session to check authentication
    const authOptions = await getAuthOptions()
    const session = await getServerSession(authOptions)

    // Check if user is authenticated
    if (!session?.user) {
      return NextResponse.json(
        { error: 'Unauthorized - Please log in' },
        { status: 401 }
      )
    }

    // Check if user has admin role (SUPER_ADMIN or PLANT_MANAGER)
    const userRole = (session.user as any).role
    if (userRole !== 'SUPER_ADMIN' && userRole !== 'PLANT_MANAGER') {
      return NextResponse.json(
        { error: 'Forbidden - Insufficient permissions' },
        { status: 403 }
      )
    }

    // Parse request body
    const body = await request.json()
    const {
      name,
      description,
      shortDescription,
      price,
      compareAtPrice,
      sku,
      stockQuantity,
      lowStockThreshold,
      weight,
      dimensions,
      categoryId,
      images = [],
      isFeatured = false,
      careLevel,
      lightRequirement,
      wateringFrequency,
      isPetSafe,
      plantSize,
      growthRate,
      careInstructions,
      metaTitle,
      metaDescription
    } = body

    // Validate required fields
    if (!name || !price || !categoryId || !stockQuantity) {
      return NextResponse.json(
        { error: 'Missing required fields: name, price, categoryId, stockQuantity' },
        { status: 400 }
      )
    }

    // Validate and convert data types
    let convertedPrice: Decimal
    let convertedCompareAtPrice: Decimal | undefined
    let convertedStockQuantity: number
    let convertedLowStockThreshold: number = 10
    let convertedWeight: Decimal | undefined

    try {
      // Convert price to Decimal
      convertedPrice = new Decimal(parseFloat(price.toString()))
      if (convertedPrice.isNaN() || convertedPrice.isNegative()) {
        throw new Error('Invalid price')
      }

      // Convert compareAtPrice if provided
      if (compareAtPrice !== undefined && compareAtPrice !== null && compareAtPrice !== '') {
        convertedCompareAtPrice = new Decimal(parseFloat(compareAtPrice.toString()))
        if (convertedCompareAtPrice.isNaN() || convertedCompareAtPrice.isNegative()) {
          throw new Error('Invalid compare at price')
        }
      }

      // Convert stockQuantity to integer
      convertedStockQuantity = parseInt(stockQuantity.toString())
      if (isNaN(convertedStockQuantity) || convertedStockQuantity < 0) {
        throw new Error('Invalid stock quantity')
      }

      // Convert lowStockThreshold if provided
      if (lowStockThreshold !== undefined && lowStockThreshold !== null) {
        convertedLowStockThreshold = parseInt(lowStockThreshold.toString())
        if (isNaN(convertedLowStockThreshold) || convertedLowStockThreshold < 0) {
          throw new Error('Invalid low stock threshold')
        }
      }

      // Convert weight if provided
      if (weight !== undefined && weight !== null && weight !== '') {
        convertedWeight = new Decimal(parseFloat(weight.toString()))
        if (convertedWeight.isNaN() || convertedWeight.isNegative()) {
          throw new Error('Invalid weight')
        }
      }
    } catch (error) {
      return NextResponse.json(
        { error: `Invalid data types: ${error instanceof Error ? error.message : 'Unknown error'}` },
        { status: 400 }
      )
    }

    // Check if category exists
    const category = await prisma.category.findUnique({
      where: { id: categoryId }
    })

    if (!category) {
      return NextResponse.json(
        { error: 'Category not found' },
        { status: 400 }
      )
    }

    // Generate slug from name
    const slug = name
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/(^-|-$)/g, '')

    // Check if slug is unique
    const existingProduct = await prisma.product.findUnique({
      where: { slug }
    })

    if (existingProduct) {
      return NextResponse.json(
        { error: 'Product with this name already exists (slug conflict)' },
        { status: 400 }
      )
    }

    // Check if SKU is unique (if provided)
    if (sku) {
      const existingSku = await prisma.product.findUnique({
        where: { sku }
      })

      if (existingSku) {
        return NextResponse.json(
          { error: 'Product with this SKU already exists' },
          { status: 400 }
        )
      }
    }

    // Create the product
    const newProduct = await prisma.product.create({
      data: {
        name,
        slug,
        description,
        shortDescription,
        price: convertedPrice,
        compareAtPrice: convertedCompareAtPrice,
        sku,
        stockQuantity: convertedStockQuantity,
        lowStockThreshold: convertedLowStockThreshold,
        weight: convertedWeight,
        dimensions,
        categoryId,
        isFeatured,
        careLevel,
        lightRequirement,
        wateringFrequency,
        isPetSafe,
        plantSize,
        growthRate,
        careInstructions,
        metaTitle,
        metaDescription,
        isActive: true,
        sortOrder: 0,
        // Create related images if provided
        images: {
          create: images.map((image: any, index: number) => ({
            url: image.url || image,
            altText: image.altText || `${name} - Image ${index + 1}`,
            sortOrder: index,
            isPrimary: index === 0
          }))
        }
      },
      include: {
        category: true,
        images: {
          orderBy: { sortOrder: 'asc' }
        }
      }
    })

    return NextResponse.json(
      {
        message: 'Product created successfully',
        product: newProduct
      },
      { status: 201 }
    )

  } catch (error) {
    console.error('Admin product creation error:', error)
    
    // Handle Prisma-specific errors
    if (error instanceof Error) {
      if (error.message.includes('Unique constraint failed')) {
        return NextResponse.json(
          { error: 'Product with this slug or SKU already exists' },
          { status: 400 }
        )
      }
    }

    return NextResponse.json(
      { error: 'Internal server error while creating product' },
      { status: 500 }
    )
  }
}



--- API ROUTE: /app/api/auth/signup/route.ts ---

import { NextRequest, NextResponse } from 'next/server'
import bcrypt from 'bcryptjs'
import { prisma } from '@/lib/db'

export async function POST(request: NextRequest) {
  try {
    const { name, email, password } = await request.json()

    if (!name || !email || !password) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      )
    }

    if (password.length < 6) {
      return NextResponse.json(
        { error: 'Password must be at least 6 characters' },
        { status: 400 }
      )
    }

    // Check if user already exists
    const existingUser = await prisma.user.findUnique({
      where: { email }
    })

    if (existingUser) {
      return NextResponse.json(
        { error: 'User already exists' },
        { status: 400 }
      )
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(password, 12)

    // Create user
    const user = await prisma.user.create({
      data: {
        name,
        email,
        password: hashedPassword,
        role: 'CUSTOMER'
      },
      select: {
        id: true,
        name: true,
        email: true,
        role: true,
        createdAt: true
      }
    })

    return NextResponse.json(
      { 
        message: 'User created successfully',
        user 
      },
      { status: 201 }
    )
  } catch (error) {
    console.error('Signup error:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}



--- API ROUTE: /app/api/auth/[...nextauth]/route.ts ---



--- API ROUTE: /app/api/cart/route.ts ---

export const dynamic = 'force-dynamic'

import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { prisma } from '@/lib/db'

export async function GET() {
  try {
    const session = await getServerSession()

    if (!session?.user?.email) {
      return NextResponse.json({ items: [] })
    }

    const user = await prisma.user.findUnique({
      where: { email: session.user.email }
    })

    if (!user) {
      return NextResponse.json({ items: [] })
    }

    const cartItems = await prisma.cartItem.findMany({
      where: { userId: user.id },
      include: {
        product: {
          include: {
            images: {
              orderBy: { sortOrder: 'asc' }
            }
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    })

    return NextResponse.json({ items: cartItems })
  } catch (error) {
    console.error('Cart fetch error:', error)
    return NextResponse.json(
      { error: 'Failed to fetch cart' },
      { status: 500 }
    )
  }
}

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession()

    if (!session?.user?.email) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      )
    }

    const { productId, quantity = 1 } = await request.json()

    const user = await prisma.user.findUnique({
      where: { email: session.user.email }
    })

    if (!user) {
      return NextResponse.json(
        { error: 'User not found' },
        { status: 404 }
      )
    }

    // Check if product exists and is active
    const product = await prisma.product.findUnique({
      where: { id: productId, isActive: true }
    })

    if (!product) {
      return NextResponse.json(
        { error: 'Product not found' },
        { status: 404 }
      )
    }

    if (product.stockQuantity < quantity) {
      return NextResponse.json(
        { error: 'Insufficient stock' },
        { status: 400 }
      )
    }

    // Check if item already exists in cart
    const existingItem = await prisma.cartItem.findUnique({
      where: {
        userId_productId: {
          userId: user.id,
          productId: productId
        }
      }
    })

    if (existingItem) {
      // Update quantity
      const newQuantity = existingItem.quantity + quantity
      if (newQuantity > product.stockQuantity) {
        return NextResponse.json(
          { error: 'Insufficient stock' },
          { status: 400 }
        )
      }

      await prisma.cartItem.update({
        where: { id: existingItem.id },
        data: { quantity: newQuantity }
      })
    } else {
      // Create new cart item
      await prisma.cartItem.create({
        data: {
          userId: user.id,
          productId: productId,
          quantity: quantity
        }
      })
    }

    return NextResponse.json({ message: 'Item added to cart' })
  } catch (error) {
    console.error('Add to cart error:', error)
    return NextResponse.json(
      { error: 'Failed to add item to cart' },
      { status: 500 }
    )
  }
}

export async function PUT(request: NextRequest) {
  try {
    const session = await getServerSession()

    if (!session?.user?.email) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      )
    }

    const { itemId, quantity } = await request.json()

    const user = await prisma.user.findUnique({
      where: { email: session.user.email }
    })

    if (!user) {
      return NextResponse.json(
        { error: 'User not found' },
        { status: 404 }
      )
    }

    // Get cart item with product info
    const cartItem = await prisma.cartItem.findFirst({
      where: {
        id: itemId,
        userId: user.id
      },
      include: { product: true }
    })

    if (!cartItem) {
      return NextResponse.json(
        { error: 'Cart item not found' },
        { status: 404 }
      )
    }

    if (quantity > cartItem.product.stockQuantity) {
      return NextResponse.json(
        { error: 'Insufficient stock' },
        { status: 400 }
      )
    }

    if (quantity <= 0) {
      // Remove item if quantity is 0 or less
      await prisma.cartItem.delete({
        where: { id: itemId }
      })
    } else {
      // Update quantity
      await prisma.cartItem.update({
        where: { id: itemId },
        data: { quantity }
      })
    }

    return NextResponse.json({ message: 'Cart updated' })
  } catch (error) {
    console.error('Update cart error:', error)
    return NextResponse.json(
      { error: 'Failed to update cart' },
      { status: 500 }
    )
  }
}

export async function DELETE(request: NextRequest) {
  try {
    const session = await getServerSession()

    if (!session?.user?.email) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      )
    }

    const { itemId } = await request.json()

    const user = await prisma.user.findUnique({
      where: { email: session.user.email }
    })

    if (!user) {
      return NextResponse.json(
        { error: 'User not found' },
        { status: 404 }
      )
    }

    await prisma.cartItem.deleteMany({
      where: {
        id: itemId,
        userId: user.id
      }
    })

    return NextResponse.json({ message: 'Item removed from cart' })
  } catch (error) {
    console.error('Remove from cart error:', error)
    return NextResponse.json(
      { error: 'Failed to remove item from cart' },
      { status: 500 }
    )
  }
}



--- API ROUTE: /app/api/cart/clear/route.ts ---

export const dynamic = 'force-dynamic'

import { NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { prisma } from '@/lib/db'

export async function POST() {
  try {
    const session = await getServerSession()

    if (!session?.user?.email) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      )
    }

    const user = await prisma.user.findUnique({
      where: { email: session.user.email }
    })

    if (!user) {
      return NextResponse.json(
        { error: 'User not found' },
        { status: 404 }
      )
    }

    await prisma.cartItem.deleteMany({
      where: { userId: user.id }
    })

    return NextResponse.json({ message: 'Cart cleared' })
  } catch (error) {
    console.error('Clear cart error:', error)
    return NextResponse.json(
      { error: 'Failed to clear cart' },
      { status: 500 }
    )
  }
}



--- API ROUTE: /app/api/products/route.ts ---

export const dynamic = 'force-dynamic'

import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/db'

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const page = parseInt(searchParams.get('page') || '1')
    const limit = parseInt(searchParams.get('limit') || '12')
    const category = searchParams.get('category')
    const careLevel = searchParams.get('careLevel')
    const lightRequirement = searchParams.get('lightRequirement')
    const isPetSafe = searchParams.get('isPetSafe')
    const plantSize = searchParams.get('plantSize')
    const sortBy = searchParams.get('sortBy') || 'name'
    const sortOrder = searchParams.get('sortOrder') || 'asc'
    const minPrice = searchParams.get('minPrice')
    const maxPrice = searchParams.get('maxPrice')

    const skip = (page - 1) * limit

    // Build where clause
    const where: any = {
      isActive: true,
    }

    if (category) {
      where.category = {
        slug: category
      }
    }

    if (careLevel) {
      where.careLevel = careLevel
    }

    if (lightRequirement) {
      where.lightRequirement = lightRequirement
    }

    if (isPetSafe !== null && isPetSafe !== undefined) {
      where.isPetSafe = isPetSafe === 'true'
    }

    if (plantSize) {
      where.plantSize = plantSize
    }

    if (minPrice || maxPrice) {
      where.price = {}
      if (minPrice) where.price.gte = parseFloat(minPrice)
      if (maxPrice) where.price.lte = parseFloat(maxPrice)
    }

    // Build order clause
    const orderBy: any = {}
    if (sortBy === 'price') {
      orderBy.price = sortOrder
    } else if (sortBy === 'created') {
      orderBy.createdAt = sortOrder
    } else {
      orderBy.name = sortOrder
    }

    const [products, total] = await Promise.all([
      prisma.product.findMany({
        where,
        include: {
          category: true,
          images: {
            orderBy: { sortOrder: 'asc' }
          },
          reviews: {
            where: { isApproved: true },
            select: { rating: true }
          }
        },
        orderBy,
        skip,
        take: limit,
      }),
      prisma.product.count({ where })
    ])

    // Calculate average ratings
    const productsWithRatings = products.map((product: any) => ({
      ...product,
      averageRating: product.reviews.length > 0
        ? product.reviews.reduce((acc: number, review: any) => acc + review.rating, 0) / product.reviews.length
        : 0,
      reviewCount: product.reviews.length
    }))

    return NextResponse.json({
      products: productsWithRatings,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    })
  } catch (error) {
    console.error('Products fetch error:', error)
    return NextResponse.json(
      { error: 'Failed to fetch products' },
      { status: 500 }
    )
  }
}



--- API ROUTE: /app/api/products/featured/route.ts ---

export const dynamic = 'force-dynamic'

import { NextResponse } from 'next/server'
import { prisma } from '@/lib/db'

export async function GET() {
  try {
    const products = await prisma.product.findMany({
      where: {
        isActive: true,
        isFeatured: true,
      },
      include: {
        category: true,
        images: {
          orderBy: { sortOrder: 'asc' }
        },
        reviews: {
          where: { isApproved: true },
          select: { rating: true }
        }
      },
      orderBy: { sortOrder: 'asc' },
      take: 8
    })

    // Calculate average ratings
    const productsWithRatings = products.map((product: any) => ({
      ...product,
      averageRating: product.reviews.length > 0
        ? product.reviews.reduce((acc: number, review: any) => acc + review.rating, 0) / product.reviews.length
        : 0,
      reviewCount: product.reviews.length
    }))

    return NextResponse.json({
      products: productsWithRatings
    })
  } catch (error) {
    console.error('Featured products fetch error:', error)
    return NextResponse.json(
      { error: 'Failed to fetch featured products' },
      { status: 500 }
    )
  }
}



--- API ROUTE: /app/api/products/[slug]/route.ts ---



--- API ROUTE: /app/api/search/route.ts ---

export const dynamic = 'force-dynamic'

import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/db'

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const query = searchParams.get('q')

    if (!query || query.trim().length < 2) {
      return NextResponse.json({ products: [] })
    }

    const products = await prisma.product.findMany({
      where: {
        isActive: true,
        OR: [
          {
            name: {
              contains: query,
              mode: 'insensitive'
            }
          },
          {
            description: {
              contains: query,
              mode: 'insensitive'
            }
          },
          {
            category: {
              name: {
                contains: query,
                mode: 'insensitive'
              }
            }
          }
        ]
      },
      include: {
        category: {
          select: {
            name: true
          }
        },
        images: {
          where: { isPrimary: true },
          take: 1
        }
      },
      take: 10,
      orderBy: {
        name: 'asc'
      }
    })

    return NextResponse.json({ products })
  } catch (error) {
    console.error('Search error:', error)
    return NextResponse.json(
      { error: 'Failed to search products' },
      { status: 500 }
    )
  }
}



================================================================================
ðŸ“ PROJECT STRUCTURE
================================================================================

File                                     
----                                     
/components.json                         
/next-env.d.ts                           
/next.config.js                          
/package-lock.json                       
/package.json                            
/postcss.config.js                       
/tailwind.config.ts                      
/tsconfig.json                           
/app/layout.tsx                          
/app/page.tsx                            
/app/admin/page.tsx                      
/app/api/admin/products/route.ts         
/app/api/auth/signup/route.ts            
/app/api/cart/route.ts                   
/app/api/cart/clear/route.ts             
/app/api/products/route.ts               
/app/api/products/featured/route.ts      
/app/api/products/[slug]/route.ts        
/app/api/search/route.ts                 
/app/auth/signin/page.tsx                
/app/auth/signup/page.tsx                
/app/collections/page.tsx                
/app/collections/[category]/page.tsx     
/app/contact/page.tsx                    
/app/plant-care/page.tsx                 
/app/products/[slug]/page.tsx            
/app/returns/page.tsx                    
/app/shipping/page.tsx                   
/components/auth-provider.tsx            
/components/theme-provider.tsx           
/components/cart/cart-item-card.tsx      
/components/cart/cart-sheet.tsx          
/components/collections/category-grid.tsx
/components/home/featured-categories.tsx 
/components/home/featured-products.tsx   
/components/home/hero-section.tsx        
/components/home/newsletter-section.tsx  
/components/home/plant-care-section.tsx  
/components/layout/footer.tsx            
/components/layout/header.tsx            
/components/layout/mobile-menu.tsx       
/components/layout/navigation-menu.tsx   
/components/layout/user-menu.tsx         
/components/products/product-details.tsx 
/components/products/product-filters.tsx 
/components/products/product-grid.tsx    
/components/products/product-images.tsx  
/components/products/product-tabs.tsx    
/components/products/related-products.tsx
/components/search/search-dialog.tsx     
/components/ui/accordion.tsx             
/components/ui/alert-dialog.tsx          
/components/ui/alert.tsx                 
/components/ui/aspect-ratio.tsx          
/components/ui/avatar.tsx                
/components/ui/badge.tsx                 
/components/ui/breadcrumb.tsx            
/components/ui/button.tsx                
/components/ui/calendar.tsx              
/components/ui/card.tsx                  
/components/ui/carousel.tsx              
/components/ui/checkbox.tsx              
/components/ui/collapsible.tsx           
/components/ui/command.tsx               
/components/ui/context-menu.tsx          
/components/ui/date-range-picker.tsx     
/components/ui/dialog.tsx                
/components/ui/drawer.tsx                
/components/ui/dropdown-menu.tsx         
/components/ui/form.tsx                  
/components/ui/hover-card.tsx            
/components/ui/input-otp.tsx             
/components/ui/input.tsx                 
/components/ui/label.tsx                 
/components/ui/menubar.tsx               
/components/ui/navigation-menu.tsx       
/components/ui/pagination.tsx            
/components/ui/popover.tsx               
/components/ui/progress.tsx              
/components/ui/radio-group.tsx           
/components/ui/resizable.tsx             
/components/ui/scroll-area.tsx           
/components/ui/select.tsx                
/components/ui/separator.tsx             
/components/ui/sheet.tsx                 
/components/ui/skeleton.tsx              
/components/ui/slider.tsx                
/components/ui/sonner.tsx                
/components/ui/switch.tsx                
/components/ui/table.tsx                 
/components/ui/tabs.tsx                  
/components/ui/task-card.tsx             
/components/ui/textarea.tsx              
/components/ui/toast.tsx                 
/components/ui/toaster.tsx               
/components/ui/toggle-group.tsx          
/components/ui/toggle.tsx                
/components/ui/tooltip.tsx               
/components/ui/use-toast.ts              
/hooks/use-cart.ts                       
/hooks/use-toast.ts                      
/lib/db.ts                               
/lib/types.ts                            
/lib/utils.ts                            
/scripts/seed.ts                         




================================================================================
ðŸš€ DEPLOYMENT SUMMARY
================================================================================
- Project Type: Next.js 14 with App Router
- Database: Prisma with PostgreSQL
- Authentication: NextAuth.js
- API Routes: 9
- Ready for DigitalOcean App Platform: âœ… YES

================================================================================
END OF EXPORT
================================================================================
